/** * P&L Calculator - Gain/loss calculations for TrenchSniper OS v0.2.0 */ import type { Trade, PositionPnL, TokenPnL, WalletPnL, PnLReport, PnLFilter, DailyPnL } from './types.js'; /** Calculate P&L for trades/positions */ export class PnLCalculator { private static readonly LAMPORTS_PER_SOL = 1_000_000_000; /** Calculate realized P&L for a trade */ static calculateTradePnL( trade: Trade, avgEntryPrice: number ): { realizedPnLSol: number; realizedPnLPercent: number } { const pnlSol = trade.side === 'sell' ? trade.solAmount - (trade.tokenAmount * avgEntryPrice) : 0; const pnlPercent = trade.side === 'sell' && avgEntryPrice > 0 ? ((trade.price - avgEntryPrice) / avgEntryPrice) * 100 : 0; return { realizedPnLSol: pnlSol, realizedPnLPercent: pnlPercent, }; } /** Calculate position P&L */ static calculatePositionPnL( position: Omit<PositionPnL, 'realizedPnLSol' | 'realizedPnLPercent' | 'unrealizedPnLSol' | 'unrealizedPnLPercent' | 'totalPnLSol' | 'totalPnLPercent'> ): Pick<PositionPnL, 'realizedPnLSol' | 'realizedPnLPercent' | 'unrealizedPnLSol' | 'unrealizedPnLPercent' | 'totalPnLSol' | 'totalPnLPercent'> { // Realized P&L from completed trades const realizedPnLSol = position.solReceived - (position.realizedTokens ?? 0) * position.entryPrice; const realizedTrades = position.trades.filter(t => t.side === 'sell' && t.status === 'completed'); const totalEntryCost = realizedTrades.reduce((sum, t) => sum + (t.tokenAmount * position.entryPrice), 0); const realizedPnLPercent = totalEntryCost > 0 ? ((position.solReceived - totalEntryCost) / totalEntryCost) * 100 : 0; // Unrealized P&L from remaining tokens const unrealizedPnLSol = (position.currentPrice - position.entryPrice) * position.tokenAmount; const unrealizedPnLPercent = position.entryPrice > 0 ? ((position.currentPrice - position.entryPrice) / position.entryPrice) * 100 : 0; // Total P&L const totalPnLSol = realizedPnLSol + unrealizedPnLSol; const totalPnLPercent = position.solSpent > 0 ? (((realizedPnLSol + position.solReceived) / position.solSpent) - 1) * 100 : 0; return { realizedPnLSol, realizedPnLPercent, unrealizedPnLSol, unrealizedPnLPercent, totalPnLSol, totalPnLPercent, }; } /** Calculate token-level P&L */ static calculateTokenPnL( trades: Trade[] ): Omit<TokenPnL, 'tokenMint' | 'tokenSymbol' | 'tokenName'> { const buys = trades.filter(t => t.side === 'buy' && t.status === 'completed'); const sells = trades.filter(t => t.side === 'sell' && t.status === 'completed'); const totalBuys = buys.length; const totalSells = sells.length; const totalTrades = buys.length + sells.length; // Aggregates const totalSolSpent = buys.reduce((sum, t) => sum + t.solAmount, 0); const totalSolReceived = sells.reduce((sum, t) => sum + t.solAmount, 0); const totalTokensBought = buys.reduce((sum, t) => sum + t.tokenAmount, 0); const totalTokensSold = sells.reduce((sum, t) => sum + t.tokenAmount, 0); // Average buy price const avgBuyPrice = totalTokensBought > 0 ? totalSolSpent / totalTokensBought : 0; // Current remaining tokens const remainingTokens = totalTokensBought - totalTokensSold; // Realized P&L const realizedPnLSol = totalSolReceived - (totalTokensSold * avgBuyPrice); const realizedPnLPercent = totalSolSpent > 0 ? (realizedPnLSol / totalSolSpent) * 100 : 0; // Unrealized (if we have current price, otherwise 0) const lastSell = sells[sells.length - 1]; const currentPrice = lastSell?.price ?? avgBuyPrice; const unrealizedPnLSol = remainingTokens > 0 ? (currentPrice - avgBuyPrice) * remainingTokens : 0; // Total including unrealized const totalPnLSol = realizedPnLSol + unrealizedPnLSol; const totalPnLPercent = totalSolSpent > 0 ? (totalPnLSol / totalSolSpent) * 100 : 0; // Best/worst multipliers const sellMultipliers = sells.map(s => { const correspondingBuy = buys.find(b => Math.abs(b.timestamp - s.timestamp) < 60000); const entryPrice = correspondingBuy?.price ?? avgBuyPrice; return entryPrice > 0 ? s.price / entryPrice : 1; }); const bestMultiplier = sellMultipliers.length > 0 ? Math.max(...sellMultipliers) : 1; const worstMultiplier = sellMultipliers.length > 0 ? Math.min(...sellMultipliers) : 1; return { totalTrades, totalBuys, totalSells, totalSolSpent, totalSolReceived, realizedPnLSol, realizedPnLPercent: parseFloat(realizedPnLPercent.toFixed(2)), unrealizedPnLSol, totalPnLSol, totalPnLPercent: parseFloat(totalPnLPercent.toFixed(2)), avgBuyPrice, currentPrice, bestMultiplier: parseFloat(bestMultiplier.toFixed(2)), worstMultiplier: parseFloat(worstMultiplier.toFixed(2)), lastTradeTime: trades.length > 0 ? Math.max(...trades.map(t => t.timestamp)) : 0, }; } /** Calculate wallet P&L */ static calculateWalletPnL( trades: Trade[], positions: PositionPnL[] ): Omit<WalletPnL, 'walletAddress'> { const completedTrades = trades.filter(t => t.status === 'completed'); const realizedPnLSol = completedTrades.filter(t => t.side === 'sell').reduce((sum, t) => sum + PnLCalculator.calculateTradePnL(t, t.price).realizedPnLSol, 0); // Win/loss analysis from closed positions const closedPositions = positions.filter(p => p.status === 'closed'); let winCount = 0; let lossCount = 0; let breakevenCount = 0; let totalWinPercent = 0; let totalLossPercent = 0; let largestWin = 0; let largestLoss = 0; for (const pos of closedPositions) { if (pos.totalPnLPercent > 1) { winCount++; totalWinPercent += pos.totalPnLPercent; largestWin = Math.max(largestWin, pos.totalPnLSol); } else if (pos.totalPnLPercent < -1) { lossCount++; totalLossPercent += Math.abs(pos.totalPnLPercent); largestLoss = Math.max(largestLoss, Math.abs(pos.totalPnLSol)); } else { breakevenCount++; } } const totalTrades = completedTrades.length; const winRate = totalTrades > 0 ? (winCount / totalTrades) * 100 : 0; const avgWinPercent = winCount > 0 ? totalWinPercent / winCount : 0; const avgLossPercent = lossCount > 0 ? totalLossPercent / lossCount : 0; // Totals const totalSolSpent = trades.filter(t => t.side === 'buy').reduce((sum, t) => sum + t.solAmount, 0); const totalSolReceived = trades.filter(t => t.side === 'sell').reduce((sum, t) => sum + t.solAmount, 0); const realizedTotal = totalSolReceived - (totalSolSpent * (totalSolReceived / (totalSolReceived + realizedPnLSol || 1))); const realizedPnLPercent = totalSolSpent > 0 ? ((totalSolReceived / totalSolSpent) - 1) * 100 : 0; // Open positions const openPositions = positions.filter(p => p.status === 'open'); const unrealizedPnLSol = openPositions.reduce((sum, p) => sum + p.unrealizedPnLSol, 0); const unrealizedPnLPercent = totalSolSpent > 0 ? (unrealizedPnLSol / totalSolSpent) * 100 : 0; const totalPnLSol = realizedPnLSol + unrealizedPnLSol; return { totalTrades, totalTokens: positions.length, totalSolSpent, totalSolReceived, realizedPnLSol, realizedPnLPercent: parseFloat(realizedPnLPercent.toFixed(2)), unrealizedPnLSol, unrealizedPnLPercent: parseFloat(unrealizedPnLPercent.toFixed(2)), totalPnLSol, totalPnLPercent: parseFloat(((totalSolSpent > 0 ? (totalPnLSol / totalSolSpent) * 100 : 0)).toFixed(2)), winCount, lossCount, breakevenCount, winRate: parseFloat(winRate.toFixed(2)), avgWinPercent: parseFloat(avgWinPercent.toFixed(2)), avgLossPercent: parseFloat(avgLossPercent.toFixed(2)), largestWin: parseFloat(largestWin.toFixed(6)), largestLoss: parseFloat(largestLoss.toFixed(6)), }; } /** Format SOL to readable string */ static formatSol(lamports: number): string { return `${(lamports).toFixed(4)} SOL`; } /** Format percentage */ static formatPercent(percent: number): string { const sign = percent >= 0 ? '+' : ''; return `${sign}${percent.toFixed(2)}%`; } /** Get emoji for P&L */ static getTrendEmoji(pnl: number): string { if (pnl > 10) return 'ðŸš€'; if (pnl > 0) return 'ðŸ“ˆ'; if (pnl > -10) return 'ðŸ“‰'; return 'ðŸ’€'; } }
